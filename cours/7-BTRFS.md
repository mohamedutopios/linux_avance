Je vais préparer un guide détaillé et pratique sur **Btrfs**, en expliquant ses principales fonctionnalités tout en fournissant des commandes concrètes pour chaque aspect. Ce guide couvrira :

- **Présentation de Btrfs** : Historique et caractéristiques générales.
- **Volumes et Subvolumes** : Création, gestion et différences avec les partitions classiques.
- **Snapshots** : Création, gestion et restauration d’instantanés.
- **Copy-on-Write (CoW)** : Explication et impact sur les performances et la gestion des fichiers.
- **Compression** : Activation et types de compression supportés (zlib, lzo, zstd).
- **Redondance et RAID** : Gestion des modes RAID intégrés à Btrfs.
- **Outils et bonnes pratiques** : Commandes utiles pour l’administration et la maintenance.

Je vais inclure des **exemples concrets et détaillés** avec des explications pour assurer une compréhension approfondie de chaque fonctionnalité. Je vous préviens dès que le guide est prêt.

# Guide pratique du système de fichiers Btrfs sous Linux

## 1. Présentation de Btrfs

Btrfs (B-Tree File System, prononcé *ButterFS*) est un système de fichiers moderne **à copie sur écriture** (*Copy-on-Write* ou CoW) conçu pour apporter des fonctionnalités avancées tout en améliorant la tolérance aux pannes et la facilité d’administration ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Btrfs%20is%20a%20modern%20copy,tolerance%2C%20repair%20and%20easy%20administration)). Contrairement à ext4 (évolution d’ext2/3), Btrfs a été pensé différemment et introduit des capacités inédites dans les systèmes de fichiers Linux ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=Btrfs%20%28B,de%20fichiers%20est%20%20stable)). Officiellement déclaré stable, il est intégré dans le noyau Linux et adopté par plusieurs distributions (openSUSE, Fedora, etc.).

**Principales caractéristiques et avantages de Btrfs :**

- **Copy-on-Write (CoW)** – Btrfs n’écrase jamais des données en place : lors d’une modification, il écrit les nouvelles données ailleurs puis met à jour les métadonnées pour pointer vers ces blocs ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=By%20default%2C%20Btrfs%20uses%20copy,well%20as%20advantages%20and%20disadvantages)). Ce principe permet des opérations atomiques et sécurise l’intégrité en cas de panne (l’ancienne donnée reste intacte tant que la nouvelle n’est pas entièrement écrite). CoW est la base de plusieurs fonctionnalités suivantes, comme les instantanés.
- **Instantanés (*snapshots*)** – Btrfs peut créer des instantanés d’un système de fichiers sans dupliquer physiquement toutes les données. Un instantané est essentiellement un sous-volume (voir ci-dessous) qui **partage les mêmes données initiales** que le volume original grâce au CoW ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,Snapshots%20for%20details)). Cela permet d’avoir des points de restauration instantanés et peu coûteux en espace.
- **Sous-volumes** – Btrfs introduit la notion de *subvolume* (sous-volume) : ce sont des volumes logiques internes au système de fichiers, comparables à des répertoires indépendants pouvant être montés séparément. Ils offrent une alternative flexible aux partitions traditionnelles en permettant de découper l’espace en plusieurs unités logiques sans contrainte de taille fixe.
- **Intégrité des données** – Btrfs intègre des **sommes de contrôle (checksums)** pour chaque bloc de données et de métadonnées ([Introduction — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Introduction.html#:~:text=%2A%20Self,detection%20of%20silent%20data%20corruptions)). Le système détecte automatiquement les corruptions silencieuses (bitrot) et, si une redondance existe, il peut réparer les données de façon transparente (*self-healing*).
- **Gestion multi-disques et RAID** – Btrfs peut fonctionner sur un ou plusieurs périphériques en regroupant l’espace en un seul système de fichiers. Il prend en charge nativement plusieurs **niveaux de RAID logiciels** : RAID0, RAID1, RAID10, etc., sans nécessiter LVM ou *mdadm* ([Introduction — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Introduction.html#:~:text=,full%20copy%20of%20the%20files)). On peut ainsi ajouter ou retirer des disques à la volée et équilibrer les données entre eux.
- **Compression transparente** – Btrfs offre la **compression automatique** des fichiers à la volée (algorithmes pris en charge : zlib, LZO, Zstd) ([Introduction — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Introduction.html#:~:text=)) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Btrfs%20supports%20transparent%20and%20automatic,fastest%20compress%20algorithms%2C%20zstd%20and)). La compression réduit l’espace occupé et peut augmenter les performances I/O dans certains cas en diminuant les écritures réelles sur le disque, au prix d’une utilisation CPU modérée.
- **Autres fonctionnalités** – Citons également la **déduplication** (réunir des blocs de données identiques pour économiser de l’espace), la **défragmentation en ligne**, la **mise à l’échelle dynamique** (le système supporte des tailles massives, jusqu’à 16 exbibytes), la **conversion à chaud** d’une partition ext4 en Btrfs, et la **sauvegarde incrémentale** via l’envoi/réception d’instantanés (backup efficace intégré) ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,%C3%A9criture%20%28cf.%20plus%20bas)).

En résumé, Btrfs vise à unifier les fonctionnalités traditionnellement assurées par plusieurs couches (système de fichiers, gestionnaire de volumes, outils RAID, etc.) en une seule solution intégrée. Cela le distingue d’ext4 ou XFS qui n’offrent pas nativement de snapshots, de compression ou de RAID. Btrfs apporte une grande **flexibilité** (réallocation de l’espace entre sous-volumes, ajout de disques) et une meilleure **fiabilité des données** (grâce aux checksums et à la restauration sur erreurs) ([Introduction — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Introduction.html#:~:text=,full%20copy%20of%20the%20files)). Ces avantages en font un choix intéressant pour des serveurs de fichiers, des postes de travail exigeants ou des systèmes où la sauvegarde et l’intégrité sont critiques. Il convient toutefois de noter que certaines fonctionnalités Btrfs restent jeunes (ex: RAID5/6, voir section RAID) et que de bonnes pratiques d’administration restent indispensables (notamment les sauvegardes régulières, aucun système de fichiers n’étant infaillible).

## 2. Volumes et sous-volumes

**Sous-volumes Btrfs vs partitions classiques :** Avec les systèmes de fichiers traditionnels (ext4, XFS…), isoler différentes données nécessite de créer des **partitions** séparées sur le disque ou d’utiliser LVM. Btrfs fonctionne différemment : on peut créer **plusieurs sous-volumes dans un même système de fichiers Btrfs**, ce qui évite de prédéfinir des tailles fixes de partitions. Un *sous-volume* Btrfs est une entité logique, semblable à un dossier, mais avec son propre espace de noms d’inodes et une hiérarchie de fichiers indépendante ([Subvolumes — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Subvolumes.html#:~:text=A%20BTRFS%20subvolume%20is%20a,see%20more%20in%20Inode%20numbers)). En pratique, cela permet de **découper votre espace en sections indépendantes sans repartitionner le disque**.

Un sous-volume n’est **pas un périphérique bloc** distinct – on ne le voit pas comme */dev/sdaX* – mais il se comporte comme un répertoire que l’on peut monter séparément si souhaité ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Subvolumes)) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Subvolumes%20can%20be%20mounted%20like,a%20change%20of%20mount%20configuration)). On peut ainsi *imiter le schéma de partitions traditionnelles* en créant par exemple des sous-volumes séparés pour **`/`**, **`/home`**, **`/var`**, etc., puis en les montant individuellement dans le système ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Subvolumes%20can%20be%20mounted%20like,a%20change%20of%20mount%20configuration)). Tous ces sous-volumes partagent l’espace global du volume Btrfs sous-jacent, ce qui offre une grande flexibilité : l’espace libre est alloué aux sous-volumes selon les besoins, sans taille fixe prédéfinie.

**Création d’un système de fichiers Btrfs et volume racine :** Lorsque vous créez un système de fichiers Btrfs sur une partition (commande `mkfs.btrfs`), un **sous-volume de niveau supérieur** (ID 5) est automatiquement créé, correspondant à la racine du système de fichiers. Par défaut, si vous montez la partition Btrfs, c’est ce volume racine (top-level) qui est monté à l’emplacement choisi. On peut toutefois choisir de monter un sous-volume spécifique à la place (voir plus bas). Le sous-volume de top-level ne peut pas être supprimé, mais vous pouvez le laisser vide et utiliser des sous-volumes enfants pour organiser vos données (c’est une pratique courante afin de faciliter les modifications de structure plus tard ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Tip%3A%20Changing%20subvolume%20layouts%20is,and%20mounting%20it%20as))).

**Commandes de gestion des sous-volumes :**

- **Créer un sous-volume :** Une fois le système de fichiers Btrfs monté, utilisez la commande `btrfs subvolume create` pour créer un nouveau sous-volume. Par exemple :  
  ```bash
  # btrfs subvolume create /mnt/btrfs_pool/sousvol_home
  ```  
  Ceci crée un sous-volume nommé `sousvol_home` dans le point de montage `/mnt/btrfs_pool`. Vous pouvez le traiter comme un répertoire classique, y déplacer des données, etc. (notez que créer un sous-volume nécessite d’avoir monté la partition Btrfs en écriture) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=)).
- **Lister les sous-volumes :** Pour afficher la liste des sous-volumes existants sur un volume Btrfs, utilisez :  
  ```bash
  # btrfs subvolume list -t /mnt/btrfs_pool
  ```  
  L’option `-t` produit un affichage en table lisible, indiquant l’ID, le chemin et d’autres infos pour chaque sous-volume ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=)).
- **Supprimer un sous-volume :** Un sous-volume se supprime avec la commande `btrfs subvolume delete`. Par exemple :  
  ```bash
  # btrfs subvolume delete /mnt/btrfs_pool/sousvol_home
  ```  
  Assurez-vous que le sous-volume n’est *pas monté* au moment de la suppression (sinon cela peut corrompre le système de fichiers) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=If%20the%20subvolume%20contains%20other,r%60%2C%20%60rmdir)). La suppression d’un sous-volume est récursive (son contenu est supprimé). On peut également ajouter l’option `-R` (`--recursive`) pour supprimer en même temps ses éventuels sous-volumes enfants ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=)).
- **Monter un sous-volume :** Pour monter un sous-volume spécifique à un point de montage, on utilise l’option `subvol=` lors du montage. Par exemple, pour monter le sous-volume `sousvol_home` sur `/home` :  
  ```bash
  # mount -o subvol=sousvol_home /dev/sda1 /home
  ```  
  (où */dev/sda1* est la partition contenant le volume Btrfs). De même dans `/etc/fstab`, on peut préciser `subvol=sousvol_home` dans les options de montage. Cela permet d’attacher chaque sous-volume à un point du système de fichiers, comme on le ferait avec des partitions distinctes ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Subvolumes%20can%20be%20mounted%20like,a%20change%20of%20mount%20configuration)). À noter que la plupart des options de montage Btrfs s’appliquent au système de fichiers entier et non individuellement par sous-volume – on ne peut pas, par exemple, monter un sous-volume avec CoW désactivé et un autre avec CoW activé (voir section CoW) sur le même volume ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Note%3A%20From%20btrfs,applies%20to%20any%20other%20subvolumes)).

**Bonnes pratiques avec les sous-volumes :** Utilisez les sous-volumes pour séparer les données aux cycles de vie différents. Par exemple, sur un poste Linux, on peut avoir un sous-volume pour la racine système (`@`), un pour `/home` (`@home`), un pour les instantanés système (`@snapshots`), etc. Ainsi, on pourra prendre des instantanés de la racine sans inclure les fichiers utilisateurs (qui sont dans un autre sous-volume), ou encore exclure certains sous-volumes des opérations de sauvegarde pour réduire leur portée. Rappelez-vous qu’un instantané Btrfs *ne capture pas* les sous-volumes imbriqués – ceux-ci apparaîtront comme des dossiers vides dans l’instantané ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=with%20any%20future%20incremental%20send%2Freceive,empty%20directory%20inside%20the%20snapshot)). Il est donc souvent judicieux de placer les données sujettes à instantanés dans des sous-volumes dédiés, et de garder des sous-volumes séparés pour les données volatiles (caches, bases de données, machines virtuelles) sur lesquelles on ne souhaite pas faire d’instantanés.

## 3. Snapshots (instantanés)

L’une des fonctionnalités phares de Btrfs est la possibilité de créer des **instantanés** (*snapshots*) rapidement et sans dupliquer l’intégralité des données. Un snapshot Btrfs est en fait un cas particulier de sous-volume : **« un instantané est simplement un sous-volume qui partage ses données (et métadonnées) avec un autre sous-volume, grâce au mécanisme CoW »** ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,Snapshots%20for%20details)). Concrètement, créer un instantané ne recopie pas immédiatement les fichiers ; il marque juste un point de référence dans le temps. À partir de ce point, toute modification de données dans le volume original ou l’instantané provoquera la duplication *à la volée* (CoW) des blocs modifiés, afin que l’instantané conserve l’état antérieur.

**Propriétés des snapshots :** Un instantané Btrfs peut être **en lecture-écriture** (modifiable, on parle alors de *snapshot writable*) ou **en lecture seule** (*readonly*). Un snapshot en lecture seule fige totalement l’état d’un sous-volume à un instant T, garantissant qu’il ne sera pas altéré. Un snapshot en lecture-écriture se comporte comme un sous-volume normal qu’on peut modifier après coup (utile pour cloner un état du système et y apporter des changements indépendamment de l’original).

**Créer un instantané :** On utilise la commande `btrfs subvolume snapshot`. Syntaxe générale :  
```bash
# btrfs subvolume snapshot <source> <destination>
```  
- **Instantané en lecture-écriture (par défaut) :** Exemple, si on a un sous-volume `@` monté sur `/mnt/root` (racine du système) et qu’on veut créer un snapshot :  
  ```bash
  # btrfs subvolume snapshot /mnt/root /mnt/root_snap_2025-03-16
  ```  
  Cela crée un sous-volume `root_snap_2025-03-16` qui est un instantané de `root` à l’instant présent. Cet instantané est modifiable (writable) par défaut ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20create%20a%20snapshot%3A)).
- **Instantané en lecture seule :** Ajouter l’option `-r` (read-only) pour figer l’instantané :  
  ```bash
  # btrfs subvolume snapshot -r /mnt/root /mnt/root_snap_2025-03-16_ro
  ```  
  Maintenant `root_snap_2025-03-16_ro` est un snapshot en lecture seule, qu’on ne peut pas modifier ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,name)). On utilise ce type pour les sauvegardes ou les points de restauration système (on pourra toujours en dériver un nouveau sous-volume modifiable plus tard si besoin).
- **Lister et gérer les instantanés :** Les snapshots apparaissent dans la liste des sous-volumes (`btrfs subvolume list`). On peut les monter comme n’importe quel sous-volume. Pour les supprimer, on utilise également `btrfs subvolume delete <snapshot>` (attention à ne pas avoir de snapshot monté lors de la suppression).

Parce qu’un snapshot est un sous-volume, il **ne consomme de l’espace supplémentaire que lors des modifications ultérieures**. Au moment de la création, il pointe vers les mêmes blocs que la source. Ensuite, si un fichier est modifié dans la source, Btrfs va copier le bloc original dans le snapshot (ou vice-versa) pour préserver l’instantané, ce qui occupera de l’espace. Ainsi, plus les changements divergent après la prise d’un snapshot, plus celui-ci occupera de l’espace disque. En revanche, un snapshot supprimé libère immédiatement les blocs qui n’étaient plus référencés ailleurs.

**Non-récursivité des snapshots :** Il est crucial de savoir que *les instantanés Btrfs ne sont pas récursifs*. Si vous prenez un snapshot d’un sous-volume qui **contient lui-même des sous-volumes**, ces sous-volumes imbriqués **n’apparaîtront pas dans le contenu de l’instantané** (ils seront visibles comme des répertoires vides) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=with%20any%20future%20incremental%20send%2Freceive,empty%20directory%20inside%20the%20snapshot)). Btrfs ne copie pas automatiquement la hiérarchie entière. Pour inclure des sous-volumes dans une sauvegarde, il faut prendre des instantanés séparés de chacun, ou utiliser des outils de backup qui gèrent la récursivité (ex: `btrfs send` peut envoyer un volume entier avec ses enfants, voir ci-dessous).

**Exemples d’utilisation des snapshots :** 

- **Sauvegarde système / Restauration :** Avant une mise à jour système risquée, on peut snapshotter la racine. En cas de problème, il suffira de rebooter sur l’instantané pour retrouver l’état antérieur. Des outils comme *Snapper* et *Timeshift* automatisent ce processus (prise d’instantanés planifiés ou à la demande, gestion de la rotation).
- **Environnements de test :** Dupliquer rapidement une arborescence de données pour faire des tests sans impacter l’original (par exemple, snapshotter une base de code source ou une VM avant de la modifier).
- **Sauvegarde à froid / copie de sécurité :** Prendre un instantané en lecture seule de données importantes puis l’archiver ou l’envoyer vers un autre disque.

**Envoi et réception d’instantanés (backup incrémental) :** Btrfs permet d’exporter un instantané sous forme d’un flux de données que l’on peut envoyer vers un autre emplacement (généralement un autre volume Btrfs) et y recréer le sous-volume. La commande `btrfs send` génère le flux binaire d’un snapshot, et `btrfs receive` l’applique à la destination. Par exemple, pour copier un instantané sur un disque de sauvegarde monté sur `/backup` :  
```bash
# btrfs send /mnt/root_snap_2025-03-16_ro | btrfs receive /backup
```  
Ce flux ne contient que les données propres à l’instantané envoyé. On peut aussi réaliser des **sauvegardes incrémentielles** très efficaces : si on a déjà envoyé un snapshot de la veille, on peut n’envoyer que les différences avec un nouveau snapshot du jour en utilisant l’option `-p <snapshot_précédent>` :  
```bash
# btrfs send -p /mnt/root_snap_2025-03-15_ro /mnt/root_snap_2025-03-16_ro | btrfs receive /backup
```  
La destination reconstruira uniquement les changements, ce qui minimise le volume de données transféré ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=You%20can%20also%20send%20only,do)). Cette fonctionnalité de *send/receive* fait de Btrfs un excellent outil pour les sauvegardes : vous pouvez conserver sur un disque externe une copie synchronisée de vos sous-volumes, mise à jour incrémentalement chaque jour. De nombreux outils (comme **btrbk**, **Snapper**, **Timeshift**, **Backup Operator** etc.) utilisent en coulisses `btrfs send/receive` pour réaliser des backups instantanés.

*Remarque :* Il n’est pas recommandé de transformer un snapshot read-only en writeable via la propriété `ro false` (possible avec `btrfs property set`) car cela peut poser des problèmes pour les envois incrémentiels ultérieurs ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,empty%20directory%20inside%20the%20snapshot)). Il vaut mieux créer un *nouvel* instantané writeable à partir de l’instantané RO si besoin.

## 4. Copy-on-Write (CoW) et impact sur les performances

Le fonctionnement **Copy-on-Write (CoW)** de Btrfs influence fortement ses performances et son comportement. Par défaut, *toutes* les écritures sont effectuées en CoW ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=By%20default%2C%20Btrfs%20uses%20copy,well%20as%20advantages%20and%20disadvantages)) : cela signifie que lorsque le système modifie un fichier, il n’écrase pas le bloc original sur le disque mais écrit la modification dans un nouveau bloc libre, puis met à jour la métadonnée pour pointer sur ce nouveau bloc. Le ou les anciens blocs deviennent orphelins (et pourront être libérés s’ils ne sont plus référencés, par exemple s’il n’y a pas d’instantané les pointant). Ce mécanisme assure que le système de fichiers est toujours dans un état cohérent : on n’a jamais de demi-mise à jour (soit l’ancien bloc reste valable, soit le nouveau est pleinement écrit et référencé). C’est l’inverse d’un système *in-place* classique où un bloc est modifié directement, avec les risques que cela comporte en cas d’interruption.

**Avantages du CoW :**  
- Il permet la création d’instantanés sans recopier les données, puisque les modifications ultérieures sont isolées sur de nouveaux blocs ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,Snapshots%20for%20details)). Sans CoW, un snapshot exigerait soit de bloquer les écritures, soit de dupliquer immédiatement tout le contenu pour figer un état.
- Il renforce la fiabilité : en cas de crash ou de panne électrique durant une écriture, les données précédentes ne sont pas altérées. On n’a pas besoin de fsck pour retrouver un état cohérent (les *journaux* des systèmes classiques offrent une protection similaire pour les métadonnées, mais Btrfs l’étend aux données grâce à CoW et aux checksums).
- Il facilite des fonctionnalités comme la **duplication rapide de fichiers (reflinks)** ou la **déduplication** : deux fichiers identiques peuvent partager les mêmes blocs et Btrfs n’allouera une nouvelle copie d’un bloc que si l’un des fichiers est modifié.

**Inconvénients et impact sur les performances :**  
- Le CoW engendre de la **fragmentation** : à force d’écrire de nouvelles copies de blocs réparties dans l’espace libre, les fichiers qui subissent de fréquentes modifications ne seront plus contigus sur le disque. Par exemple, un fichier base de données de 10 Go que l’on met à jour par petites écritures verra ses blocs dispersés. Cela peut dégrader les performances en lecture séquentielle ou augmenter la latence d’accès, surtout sur disque dur (moins problématique sur SSD, quoique la fragmentation peut aussi impacter le cache SSD).
- Les charges de travail à **écritures intensives aléatoires** souffrent parfois d’une baisse de performances sous Btrfs par rapport à ext4/XFS. Des cas typiques incluent : les fichiers de machines virtuelles (images disque), les bases de données (SQLite, PostgreSQL, etc.), ou le journal système. Ces workloads modifient souvent les mêmes fichiers de façon répétée, causant une sur-utilisation d’espace (beaucoup d’anciennes versions de blocs en attente de nettoyage) et plus d’I/O en écriture que nécessaire.
- En cas d’espace disque très faible, le CoW peut se retrouver à court de blocs libres pour effectuer les copies, entraînant des erreurs « No space left on device » alors que de l’espace devrait théoriquement se libérer (c’est un cas où un *balance* peut aider, voir section Outils).

**Désactivation du CoW (NOCOW) :** Btrfs offre la possibilité de **désactiver le comportement CoW** pour certains fichiers ou sous-volumes, lorsque les inconvénients surpassent les avantages. Désactiver CoW signifie que les données seront écrites en place, de manière semblable à un système de fichiers traditionnel (les métadonnées, elles, restent CoW au niveau global). Voici les méthodes et cas d’usage :

- **Attribuer l’attribut NOCOW à un fichier/répertoire :** La méthode la plus fine consiste à utiliser l’attribut de fichier **`C` (NOCOW)**. On l’applique avec la commande `chattr`. Par exemple, pour un fichier existant (vide de préférence) ou un dossier :  
  ```bash
  # chattr +C /chemin/vers/fichier_ou_dossier
  ```  
  Une fois l’attribut **+C** (No copy-on-write) défini, les nouvelles données écrites dans ce fichier ne seront plus en CoW ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20disable%20copy,files%2Fdirectories%2C%20do)). Si c’est un dossier, *tous les nouveaux fichiers créés à l’intérieur hériteront de NOCOW* ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=%24%20chattr%20%2BC%20%2Fdir%2Ffile)). **Attention :** on ne peut pas retirer l’attribut +C sur un fichier qui a déjà des données écrites en CoW ; il faut que le fichier soit vide au moment du changement d’attribut pour qu’il prenne effet ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Note%3A%20From%20Btrfs%20documentation%3A%20File,set%2Funset%20only%20on%20empty%20files)). En pratique, si vous voulez passer un gros fichier existant en NOCOW, il faut souvent le recopier : par exemple, créez un nouveau dossier +C, puis copiez-y le fichier avec `cp --reflink=never` (pour forcer une copie physique et non un clone CoW), comme suggéré ci-dessous.
- **Option de montage `nodatacow` :** On peut monter un volume Btrfs avec l’option `nodatacow` pour que **tous les nouveaux fichiers** créés sur ce volume soient en écriture directe (NOCOW) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20disable%20copy,See%20btrfs%285%29%20for%20details)). Cependant, cette option *désactive également la compression* sur tout le volume ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20disable%20copy,See%20btrfs%285%29%20for%20details)), et elle s’applique globalement (on ne peut pas avoir une partie CoW et une partie NoCoW sur le même système de fichiers selon les sous-volumes montés) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Note%3A%20From%20btrfs,applies%20to%20any%20other%20subvolumes)). De plus, les fichiers existants continuent d’être gérés en CoW. Cette option est donc rarement utilisée sauf cas spécifiques, car l’attribut +C offre un contrôle plus granulaire.

**Cas pratiques où désactiver CoW :** 

- Les **VMs et images disques** : les fichiers volumineux (plusieurs gigas) représentant des disques virtuels (formats qcow2, raw…) subissent de nombreuses écritures aléatoires. Il est fortement recommandé de stocker ces images dans un sous-volume ou dossier avec CoW désactivé (attribuez +C avant de créer ou de copier l’image) pour éviter une forte fragmentation et une baisse de performance. Par exemple :  
  ```bash
  # mkdir /var/lib/libvirt/images_nocow
  # chattr +C /var/lib/libvirt/images_nocow
  # cp --reflink=never image.qcow2 /var/lib/libvirt/images_nocow/
  ```  
  Ici on copie l’image avec `--reflink=never` pour forcer une duplication non-CoW (sinon la copie aurait partagé les blocs avec l’original, maintenant supprimé, annulant l’effet).
- Les **bases de données** (fichiers .db de SQLite, etc.) : même principe, les mettre dans un dossier NOCOW pour améliorer les I/O.  
- Le **journal système (`/var/log/journal`)** : systemd-journald désactive déjà CoW sur ses fichiers journal car ils subissent de très nombreuses petites écritures (il crée par défaut un fichier `.../journal-nocow.conf` pour que Btrfs les stocke sans CoW). Cela évite la corruption du RAID1 Btrfs due à l’async du journal ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,%C2%A7%20CONFIGURATION%20DIRECTORIES%20AND%20PRECEDENCE)).
- De manière générale, tout fichier qui est **massivement réécrit** et pour lequel la résilience offerte par CoW n’est pas nécessaire (ex : fichiers temporaires de builds, caches).

**Inconvénients de la désactivation CoW :** Lorsqu’on marque un fichier ou un sous-volume en NOCOW, **on perd les sommes de contrôle** sur ces données ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Warning%3A%20Disabling%20CoW%20in%20Btrfs,to%20become%20out%20of%20sync)). En effet, Btrfs ne calcule pas de checksum pour les blocs écrits en mode NOCOW (ils sont marqués « sans vérification »). Cela signifie que vous perdez la capacité de détection/réparation automatique de corruption silencieuse sur ces fichiers-là. En outre, en RAID1/10, si un fichier NOCOW est écrit différemment sur deux disques (par exemple à cause d’une panne pendant l’écriture sur l’un), Btrfs ne pourra pas s’en rendre compte facilement et les deux copies pourraient diverger ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Warning%3A%20Disabling%20CoW%20in%20Btrfs,to%20become%20out%20of%20sync)). Il y a donc un léger risque d’incohérence sur les fichiers NOCOW en cas de crash (analogue à ext4 sans journal). Toutefois, pour des fichiers temporaires ou répliqués ailleurs, c’est un compromis acceptable.

**CoW et instantanés :** Il faut noter que même un fichier NOCOW ne bénéficie pas entièrement du CoW _si on prend un instantané_ contenant ce fichier. Lors du **premier** write suivant la création d’un snapshot, Btrfs devra quand même copier le bloc modifié (c’est-à-dire faire une écriture CoW) car l’instantané retient l’ancienne version ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=)). Ensuite, les écritures suivantes sur ce même fichier seront bien en place (jusqu’à un prochain snapshot). Ainsi, *des snapshots très fréquents réduisent l’intérêt de NOCOW* car chaque snapshot impose une copie CoW initiale sur les fichiers modifiés ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=writes%20to%20the%20same%20file,place%20until%20the%20next%20snapshot)). La parade si vous voulez absolument qu’un fichier reste hors CoW est de le mettre dans un sous-volume que vous excluez des snapshots (par exemple, un sous-volume dédié aux données volatiles sur lesquelles vous ne faites pas d’instantané).

En résumé, **ne désactivez CoW que dans les cas justifiés** (VM, BD, journaux) où la performance prime sur la sécurité d’intégrité, et en sachant ce que vous perdez. Pour la plupart des fichiers (documents, code, etc.), laisser CoW activé vous apporte la protection des checksums et la flexibilité des snapshots sans inconvénient notable.

## 5. Compression

Btrfs supporte la **compression transparente et automatique** des données ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Btrfs%20supports%20transparent%20and%20automatic,fastest%20compress%20algorithms%2C%20zstd%20and)). Cela signifie que lorsqu’un fichier est écrit, Btrfs peut compresser les blocs de données avant de les stocker sur le disque, puis les décompresser à la volée lors de la lecture, le tout de façon invisible pour l’utilisateur. La compression offre plusieurs bénéfices : **réduction de l’espace disque utilisé**, augmentation potentielle de la **vitesse de lecture/écriture effective** (si le support de stockage est lent, lire/écrire moins de données compressées peut être plus rapide malgré le coût CPU), et sur les SSD une **diminution de l’usure** (moins de cellules écrites grâce à la réduction de données) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Btrfs%20supports%20transparent%20and%20automatic,fastest%20compress%20algorithms%2C%20zstd%20and)). Bien entendu, le gain dépend du type de données : des textes, logs, binaires ou VM vides compressent très bien ; des vidéos ou archives déjà compressées (zip, mp4) ne gagneront presque rien.

**Algorithmes de compression disponibles :** Btrfs propose actuellement trois algos : **Zlib**, **LZO** et **Zstandard (zstd)** ([Introduction — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Introduction.html#:~:text=,crc32c%2C%20xxhash%2C%20sha256%2C%20blake2b)). 

- *Zlib* est l’algorithme historique (basé sur deflate, comme gzip) offrant une bonne compression mais assez lent. 
- *LZO* est beaucoup plus rapide à compresser/décompresser, avec un taux de compression un peu moindre que zlib. Il est adapté si vous voulez minimiser l’impact CPU.
- *Zstd* (depuis Linux 4.14) est devenu le choix par défaut sur plusieurs distributions. Il offre un **excellent compromis** : compression souvent aussi bonne ou meilleure que zlib, avec une vitesse bien supérieure, surtout aux niveaux bas. Zstd supporte en outre plusieurs niveaux de compression de 1 à 15 (niveau 1 étant très rapide, 15 très compressé mais lent) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=LZO%20has%20a%20fixed%20compression,benchmarked%20before%20and%20after%20changing)). Par défaut, `compress=zstd` correspond au niveau 3.

L’algorithme et éventuellement son niveau sont configurables à l’**option de montage** du système de fichiers. 

**Activer la compression :** Pour utiliser la compression, on monte le volume Btrfs avec `compress=<algo>` (par exemple `compress=zstd`). On peut l’ajouter dans les options de `/etc/fstab`. Exemple fstab :  
```
UUID=... /mnt/data   btrfs   defaults,compress=zstd   0 0
``` 
Ici, on a choisi zstd avec son niveau par défaut. Si on veut un niveau spécifique : `compress=zstd:5` (niveau 5). Vous pouvez également spécifier `lzo` ou `zlib` de la même façon. **Note :** l’option simple `compress=` est **heuristique** – Btrfs va tester un échantillon de données au début de chaque fichier ; si la compression de ces premiers blocs ne réduit pas suffisamment la taille, il n’appliquera pas la compression au reste du fichier ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20%60compress%3Dalg,fully%20given%20to%20Btrfs%20and)). Cela évite de gaspiller du CPU à compresser des données incompressibles (par ex. un fichier vidéo déjà compressé). En revanche, cela peut faire passer à côté de gains si, par exemple, le début du fichier n’est pas représentatif. Pour forcer la compression de tous les fichiers, on peut utiliser l’option `compress-force=<algo>` (ou `compress-force=<algo>:<niveau>`) – Btrfs tentera de tout compresser, même si le bénéfice est nul ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20%60compress,is%20against%20official%20Btrfs%20guidelines)). L’usage de `compress-force` est déconseillé sauf cas particuliers, car compresser des données incompressibles consomme du CPU pour rien et va même **augmenter la taille** (un fichier déjà optimisé peut légèrement grossir en raison des en-têtes de compression).

Une fois la compression activée, **seules les nouvelles données écrites seront compressées** ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Only%20files%20created%20or%20modified,is%20added%20will%20be%20compressed)). Les fichiers déjà présents sur le disque ne sont pas recompressés automatiquement. Ils conserveront leur état (non compressé ou compressé selon l’historique). On peut vérifier la compression effective d’un fichier avec des outils comme `btrfs filesystem df` (qui montre la taille des blocs utilisés) ou mieux avec l’outil externe `compsize` qui calcule le ratio de compression.

**Appliquer la compression aux fichiers existants :** Pour compresser rétroactivement des données déjà présentes, Btrfs utilise la fonctionnalité de **défragmentation**. En effet, une opération de défragmenteur peut réécrire les fichiers, et on peut lui demander de compresser lors de cette réécriture. La commande est :  
```bash
# btrfs filesystem defragment -r -v -c<algo> <chemin>
``` 
où `<algo>` est `zlib`, `lzo` ou `zstd`. L’option `-r` rend la défrag récursive (sur tout un sous-volume, par exemple), et `-v` verbose. Par exemple, pour recompresser tout un volume en zstd :  
```bash
# btrfs filesystem defragment -r -v -czstd /mnt/data
```  
Cette commande va parcourir les fichiers et réécrire chaque fragment en compressé ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20apply%20compression%20to%20existing,zstd%2C%20run%20the%20following%20command)). **Prudence** : ne lancez pas ça sur un volume entier à la légère. D’une part, cela consomme du temps et des I/O; d’autre part, **si vous avez des snapshots**, chaque réécriture va dupliquer les blocs (puisque le snapshot retient l’ancienne version), ce qui peut *consommer beaucoup d’espace* ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=%23%20btrfs%20filesystem%20defragment%20,czstd)). Il est recommandé de supprimer ou envoyer les snapshots anciens avant de defrag+compresser, ou de cibler uniquement des répertoires sans snapshot.

**Choix de l’algorithme :** Aujourd’hui, **Zstd** est un excellent choix par défaut (Fedora, Ubuntu l’utilisent par défaut avec Btrfs). Niveau 1 ou 3 offre un bon gain avec un impact minime sur le CPU, souvent même un *gain de performances* global sur les lectures/écritures classiques ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Btrfs%20supports%20transparent%20and%20automatic,fastest%20compress%20algorithms%2C%20zstd%20and)). Si vous avez un processeur très limité ou une charge déjà lourde, *LZO* peut être envisageable : il consomme très peu de CPU et accélère certaines opérations, mais compresse moins (utile par exemple sur un Raspberry Pi avec carte SD, où le CPU est faible et où on veut réduire les écritures sur la SD). *Zlib* n’est en général plus utile sauf si vous cherchez la compression maximale et que la vitesse importe peu – auquel cas, autant utiliser zstd à niveau élevé. Vous pouvez effectuer des tests de performance sur vos données (outils de benchmark ou simplement copier un gros dossier avec différentes options) pour décider. Il est possible de combiner : par exemple, monter en `compress=zstd` pour la plupart des données, et spécifier `chattr +c` (compression forced on) sur un dossier en particulier si vous voulez absolument compresser certains fichiers au maximum (Btrfs a aussi un attribut +c pour forcer la compression d’un fichier même si l’heuristique est défavorable).

En résumé, la **compression Btrfs est un atout précieux** pour économiser de l’espace et améliorer l’efficacité des I/O dans de nombreux cas. Elle est simple à activer (option de montage) et fonctionne automatiquement. Sur un SSD, elle peut presque doubler la durée de vie du disque en réduisant les écritures nécessaires ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Btrfs%20supports%20transparent%20and%20automatic,fastest%20compress%20algorithms%2C%20zstd%20and)). Sur disque dur, elle réduit le volume stocké, et peut compenser partiellement la lenteur du disque lors des lectures. Sur CPU moderne, l’impact est généralement négligeable aux niveaux de compression bas/moyens. N’hésitez pas à l’utiliser, en particulier avec **Zstandard** qui offre un très bon compromis.

## 6. Redondance et RAID

Btrfs prend en charge la **gestion multi-disques intégrée**, avec des profils de stockage qui correspondent à des niveaux de RAID classiques. On peut créer un système de fichiers Btrfs sur **plusieurs périphériques** (disques ou partitions) et choisir comment les données sont distribuées : par exemple dupliquées en miroir, réparties en bandes (striping), avec ou sans parité, etc. ([Volume management — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Volume-management.html#:~:text=BTRFS%20filesystem%20can%20be%20created,exact%20profile%20capabilities%20and%20constraints)). L’approche Btrfs diffère d’un RAID matériel ou d’un *mdadm* traditionnel dans le sens où c’est le système de fichiers lui-même qui gère la répartition, et cela de manière **flexible** (on peut ajouter/enlever des disques en cours de route). Btrfs utilise le terme de **“profil”** de stockage pour désigner la façon dont il stocke les données et métadonnées sur les disques, mais par simplicité on parlera de RAID 0, 1, 5… par analogie.

**Modes supportés (profils de données) :** 

- **Single (linéaire)** – Les données ne sont ni dupliquées ni éclatées : ce profil utilise les disques de manière séquentielle (le 2ᵉ disque n’est utilisé que lorsque le 1ᵉʳ est plein, etc.). Il offre 100% de l’espace total en stockage utile ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,les%20deux%20premiers%20seront%20remplis)). C’est le mode par défaut sur un seul disque. Sur plusieurs disques, *single* équivaut à un agrégat JBOD linéaire (différent d’un RAID0 qui fait du striping).
- **Dup (dupliqué)** – Chaque bloc de donnée est stocké en double sur le *même* disque (ou sur chaque disque, si plusieurs ?). Ce profil est surtout utilisé par Btrfs automatiquement pour les **métadonnées sur un seul disque** : par défaut, si vous créez un Btrfs sur un disque unique, il met les métadonnées en *dup* (deux copies sur le disque) afin de pouvoir corriger une erreur de lecture éventuelle en utilisant la copie ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,les%20donn%C3%A9es%20en%20double)). On peut forcer le profil dup pour les données également, mais l’intérêt est limité sur un seul disque (sauf à se protéger d’un secteur défectueux avec la copie sur une autre zone du disque).
- **RAID0 (stripping)** – Les données sont **réparties (stripées)** en blocs alternés entre les disques, sans aucune duplication ni parité. Ce mode vise la performance : toutes les capacités des disques s’additionnent et les E/S peuvent s’effectuer en parallèle sur N disques. L’espace utile est 100% du total. Il n’y a en revanche *aucune tolérance de panne* (la perte d’un disque entraîne la perte de tout le volume). Btrfs n’exige pas que les disques soient de taille identique en RAID0 (contrairement à beaucoup de RAID0 classiques), mais la capacité du plus petit disque limitera l’utilisation de l’espace sur les plus grands (l’excès d’espace pourrait rester non utilisé) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,device%20file%20systems)) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Multiple%20devices%20can%20be%20used,m%60%20options%20respectively)).
- **RAID1 (miroir)** – Les données sont **dupliquées en deux copies** sur deux disques différents. On obtient une tolérance à la panne d’un disque : si l’un tombe en panne, l’autre a une copie complète. L’espace utile est 50% du total (puisque chaque donnée est écrite deux fois) ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,les%20disques%20seront%20utilis%C3%A9s%20simultan%C3%A9ment)). Btrfs RAID1 est un peu particulier : avec plus de deux disques, par défaut il continue d’écrire seulement deux copies, en s’assurant qu’elles sont sur des disques distincts. Cela signifie qu’avec 3 disques en RAID1, chaque bloc ira sur 2 des 3 disques (répartis de façon à équilibrer l’utilisation). Depuis le kernel 5.5, Btrfs prend aussi en charge des variantes **RAID1c3** (3 copies) et **RAID1c4** (4 copies) pour une redondance accrue ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Multiple%20devices%20can%20be%20used,m%60%20options%20respectively)). En RAID1c3, l’espace utile est ~33% (chaque donnée écrite trois fois) et on peut perdre jusqu’à 2 disques sur 3 sans perdre de données ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,disques%20peuvent%20tomber%20en%20panne)). En RAID1c4, 25% d’espace utile, tolérance de 3 pannes sur 4.
- **RAID10 (miroir + stripe)** – Combinaison de RAID1 et RAID0 : les données sont d’abord dupliquées par paire (miroir) puis réparties entre les paires (stripe). Il faut au moins 4 disques (de préférence un nombre pair). En pratique, avec 4 disques on aura deux miroirs de 2 disques chacun, et les données distribuées sur les deux miroirs. Cela donne la performance du striping tout en ayant la tolérance de panne du mirroring (on peut perdre un disque par paire). L’espace utile est 50% du total (car chaque donnée a une copie) ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,et%20RAID0)). RAID10 est souvent le meilleur compromis performance/sécurité sur 4+ disques.
- **RAID5/6 (parité)** – Btrfs implémente également RAID5 (tolérance 1 panne) et RAID6 (tolérance 2 pannes) via un schéma à parité distribuée. Le RAID5 nécessite au moins 3 disques, le RAID6 au moins 4. L’espace utile est environ 2/3 du total en RAID5 (si 3 disques, 66%; plus généralement (N-1)/N) ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,et%20RAID0)), et 4/5 en RAID6 avec 4 disques ((N-2)/N). **Cependant, il est fortement déconseillé d’utiliser RAID5/6 de Btrfs en production** à l’heure actuelle. Ces modes sont considérés *expérimentaux et instables*, avec des bugs connus pouvant mener à des pertes de données irréversibles ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Warning%3A%20Parity%20RAID%20,and%20a%20helpful%20recovery%20guide)). La fameuse « write hole » (incohérence de parité en cas de crash) n’est pas correctement gérée, et d’autres problèmes subsistent. Les développeurs indiquent clairement de ne les employer qu’à des fins de test ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=WARNING%3A%20RAID5%2F6%20support%20has%20known,used%20besides%20testing%20or%20evaluation)). En pratique, si vous avez besoin de redondance sur Btrfs, utilisez plutôt RAID1/10 (ou RAID1c3/4) qui sont robustes.

**Choisir et configurer un profil RAID :** Vous pouvez spécifier le niveau lors de la création du système de fichiers avec `mkfs.btrfs`. On distingue le profil pour les **données** (`-d` ou `--data`) et pour les **métadonnées** (`-m` ou `--metadata`). Il est recommandé de dupliquer au moins les métadonnées (par exemple, on peut faire données en single mais métadonnées en dup sur deux disques). Quelques exemples :

- **Créer un Btrfs en RAID1 (2 disques) :**  
  ```bash
  # mkfs.btrfs -m raid1 -d raid1 /dev/sda1 /dev/sdb1
  ```  
  Ici, on formate les deux partitions en un système Btrfs commun, avec deux copies pour les métadonnées et les données (RAID1). On obtient l’équivalent d’un miroir classique. L’ordre des disques n’a pas d’importance.
- **Créer un Btrfs en RAID10 (4 disques) :**  
  ```bash
  # mkfs.btrfs -m raid10 -d raid10 /dev/sda1 /dev/sdb1 /dev/sdc1 /dev/sdd1
  ```  
  On aura alors un volume distribué en RAID10 sur les 4 périphériques. Note : certains chargeurs d’amorçage (Syslinux notamment) ne supportent pas le multi-disque Btrfs ; pour /boot il vaut mieux utiliser une petite partition ext4 séparée ou vérifier la compatibilité du bootloader ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,device%20file%20systems)).
- **Créer un Btrfs multi-disques sans redondance (mode single) :**  
  ```bash
  # mkfs.btrfs -m single -d single /dev/sda1 /dev/sdb1 ...
  ```  
  Cela agrégera les disques de façon linéaire (pas de duplication). Utile si vous voulez juste fusionner la capacité de plusieurs disques (mais sans tolérance aux pannes, attention).

Si vous ne spécifiez rien, par défaut Btrfs mettra les données en **single** et les métadonnées en **dup** sur la configuration la plus simple. Sur deux disques, il passe automatiquement en RAID1 pour métadonnées (et données aussi normalement depuis des versions récentes). Consultez la documentation de `mkfs.btrfs` pour les valeurs par défaut qui ont pu évoluer.

**Gestion dynamique :** Un point fort de Btrfs est de pouvoir **modifier la composition RAID après coup**, sans reformater. On peut :

- **Ajouter un disque à un volume existant :** `btrfs device add /dev/sdx <mountpoint>` va intégrer un nouveau disque dans le volume Btrfs monté. Par exemple, si vous aviez un Btrfs sur /dev/sda1 en single et voulez passer en RAID1 sur /dev/sda1 + /dev/sdb1, faites :  
  ```bash
  # btrfs device add /dev/sdb1 /mnt/btrfs_vol
  # btrfs balance start -dconvert=raid1 -mconvert=raid1 /mnt/btrfs_vol
  ```  
  La première commande déclare le second disque dans le pool. La seconde (balance) va *convertir* les données et métadonnées existantes au nouveau profil (RAID1) en réorganisant/copiant les blocs ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,See%20Upstream%20FAQ%20page)). Après le balance (vérifiez son statut avec `btrfs balance status`), vous aurez bien deux copies de tout sur les deux disques. **Remarque :** si le volume était presque plein, il faut s’assurer d’avoir assez d’espace libre pour copier les données lors du balance, sinon la conversion peut échouer.  
- **Retirer un disque :** `btrfs device remove <dev> <mountpoint>` enlève un périphérique du volume. Btrfs va automatiquement migrer les données de ce disque vers les autres avant de le retirer (s’il est encore fonctionnel), ou vous pouvez retirer un disque manquant (défaillant) en spécifiant `missing`. Par exemple : `btrfs device remove /dev/sdb1 /mnt/btrfs_vol`. Un balance implicite a lieu pour restaurer le niveau de redondance.
- **Changer de profil RAID :** Même sans ajouter/enlever de disque, on peut convertir le profil (par ex passer de RAID1 à RAID0 si on a 2 disques, ou inversement). La commande est toujours un `btrfs balance start -dconvert=<nouveau> -mconvert=<nouveau>`. Btrfs va réécrire tous les chunks de données selon le nouveau schéma. Cela peut être long et il faut avoir suffisamment d’espace pour la recopie temporaire.

**Tolérance de panne et reconstruction :** En cas de défaillance d’un disque dans un volume redondant (RAID1/10/5/6), Btrfs continuera à fonctionner en mode *dégradé* si suffisamment de copies sont disponibles. Par exemple, sur un RAID1 à 2 disques, si l’un tombe, le volume est toujours accessible en lecture/écriture (bien qu’il faille remplacer le disque au plus vite pour rétablir la redondance). Btrfs n’a pas de notion de « disque de spare » automatique, mais vous pouvez très bien ajouter un nouveau disque et enlever l’ancien comme décrit. Il existe aussi la commande `btrfs replace` qui facilite le remplacement direct :  
```bash
# btrfs replace start <ancien_dev> <nouveau_dev> <mountpoint>
``` 
Ceci va copier toutes les données de l’ancien disque vers le nouveau en arrière-plan, puis retirer l’ancien du volume.

**Auto-réparation (self-healing) :** Lorsqu’un volume Btrfs est en RAID redondant, il peut détecter et **corriger automatiquement les erreurs de lecture** grâce aux checksums. Par exemple, en RAID1 si un bloc est corrompu sur un disque (mauvaise somme de contrôle), Btrfs va le lire sur l’autre disque, vérifier que la checksum est ok, et pourra même réécrire la bonne copie sur le disque défectueux pour le réparer ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20Btrfs%20Wiki%20Glossary%20says,and%20repair%20any%20corrupt%20data)). Ce processus peut se faire lors d’une opération de **scrub** (voir section Outils) ou même à la volée lors d’une lecture normale si une corruption est détectée. C’est un avantage considérable par rapport à du RAID1 classique qui, faute de checksum, ne sait pas distinguer la copie saine de la copie corrompue d’un bloc.

**Limitations :** Comme mentionné, le RAID5/6 de Btrfs a des problèmes graves (risque de perte de données en cas de panne + reconstruction incomplète). Il est donc conseillé d’éviter RAID5/6 pour des données importantes tant que ces problèmes ne sont pas résolus. De plus, Btrfs ne supporte pas le RAID *mélangé* pour les données : tous les data chunks sont dans un seul profil à la fois (on ne peut pas avoir une partie du volume en RAID1 et une partie en RAID0 par exemple, hormis via les subvolumes montés séparément sur des volumes aux profils différents). En revanche, on peut choisir des profils différents pour les données et les métadonnées (par exemple `-d raid0 -m raid1` pour un compromis où les données ne sont pas dupliquées mais les métadonnées oui). Ce dernier choix peut être risqué car si un disque a un secteur illisible contenant des données uniques (non répliquées), le fichier concerné sera perdu. Beaucoup recommandent d’au moins mettre les données en RAID1 également si on tient à la redondance.

## 7. Outils et bonnes pratiques d’administration Btrfs

Comme tout système de fichiers, Btrfs requiert un minimum de suivi pour fonctionner de façon optimale. Sa richesse fonctionnelle implique quelques outils spécifiques pour la maintenance. Voici les **commandes utiles** et **bonnes pratiques** pour administrer un volume Btrfs au quotidien :

### a. Surveillance de l’espace et de l’état du système de fichiers

- **`btrfs filesystem df`** : donne un aperçu de l’utilisation de l’espace sur un volume monté. Par exemple :  
  ```bash
  $ btrfs filesystem df /mnt/btrfs
  Data, single: total=50 GiB, used=47 GiB  
  Metadata, DUP: total=1 GiB, used=300 MiB  
  System, DUP: total=8 MiB, used=16 KiB
  ```  
  On voit ici que les données sont en profil *single* (pas de redondance) avec 50 GiB alloués dont 47 GiB utilisés. Les métadonnées sont en *DUP* (deux copies sur le même disque) avec 1 GiB alloué dont 300 MiB utilisés. Cette commande est précieuse pour comprendre la répartition et détecter si, par exemple, les métadonnées approchent de la saturation (ce qui pourrait nécessiter un balance).
- **`btrfs filesystem usage`** : fournit des informations plus détaillées sur l’espace (taille des chunks, fragmentation, etc.). Utile pour investiguer en profondeur l’allocation.
- **`btrfs device stats`** : affiche les statistiques d’erreurs des périphériques d’un volume. Il liste pour chaque disque le nombre d’erreurs de lecture, erreurs d'écriture, erreurs de checksum corrigées, etc. Par exemple :  
  ```
  $ btrfs device stats /mnt/btrfs
  [/dev/sda1].write_io_errs    0
  [/dev/sda1].read_io_errs     0
  [/dev/sda1].flush_io_errs    0
  [/dev/sda1].corruption_errs  0
  [/dev/sda1].generation_errs  0
  [/dev/sdb1].write_io_errs    0
  ... (etc)
  ```  
  Des valeurs non nulles ici indiqueraient des problèmes matériels ou des corruptions détectées (et normalement corrigées si redondance). Surveillez ces compteurs après des scrubs (ils se mettent à jour à chaque détection).
- **Ne pas saturer le volume** : règle empirique, évitez de remplir un volume Btrfs à 100%. À partir de ~95% d’utilisation, Btrfs peut rencontrer des difficultés à trouver des blocs libres contigus pour certaines opérations (surtout sans balance). Il est conseillé de garder une marge (quelques % libres). Si vous approchez de la limite, envisagez d’ajouter un disque (sur volume multi-disque) ou de faire un peu de ménage (supprimer des snapshots obsolètes, archiver des données ailleurs) avant d’atteindre le point de saturation.

### b. Scrub (vérification d’intégrité périodique)

Le **scrub** est l’outil Btrfs de vérification en tâche de fond de l’intégrité des données. En un mot, il **relit toutes les données et métadonnées** d’un volume monté, calcule les checksums et compare avec ceux stockés. S’il détecte une corruption, et que le volume a de la redondance (RAID1/10, DUP…), il tente de réparer automatiquement en récupérant une copie saine et en réécrivant le bloc corrompu ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20Btrfs%20Wiki%20Glossary%20says,and%20repair%20any%20corrupt%20data)). C’est donc l’équivalent d’un fsck *en ligne* proactif, à lancer régulièrement.

- **Lancer un scrub :**  
  ```bash
  # btrfs scrub start /mnt/point_de_mount
  ```  
  Cette commande démarre le scrub en tâche de fond sur le volume indiqué (ici monté sur `/mnt/point_de_mount`). Vous pouvez ajouter l’option `-B` pour le lancer en *foreground* (le terminal attendra la fin) ou `-c <id>` pour limiter la vitesse.
- **Suivre l’avancement / statut :**  
  ```bash
  # btrfs scrub status /mnt/point_de_mount
  ```  
  Affiche si un scrub est en cours, combien de données ont été vérifiées, le taux de progression, et le résultat final si terminé (nombre d’erreurs trouvées et corrigées) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20start%20a%20,file%20system%20which%20contains)).
- **Automatiser les scrubs :** Il est recommandé d’effectuer un scrub **environ une fois par mois** sur chaque système de fichiers Btrfs, afin de détecter précocement d’éventuelles corruptions. Le paquet `btrfs-progs` fournit un service **systemd** tout prêt : `btrfs-scrub@.timer` ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20btrfs,to%20escape%20the)). En activant par exemple `btrfs-scrub@-.timer`, on planifie un scrub mensuel de la racine `/` ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20btrfs,to%20escape%20the)). On peut en activer un pour chaque volume monté (le nom à utiliser est l’UUID ou le chemin échappé du volume). Cette approche est préférable à un script cron manuel, car systemd permettra de journaliser le résultat du scrub et de régler des limites (comme éviter que le scrub ne fasse surchauffer un SSD en limitant son I/O ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=On%20large%20NVMe%20drives%20with,resource))).

L’exécution régulière de scrubs est une *bonne pratique essentielle* avec Btrfs, surtout sur des volumes multi-disques. Cela vous assure que toute altération silencieuse sera repérée et corrigée tant que vous avez des copies saines. Même sur un seul disque, un scrub peut détecter une corruption (il ne pourra pas la corriger faute de copie, mais au moins vous serez alerté que le fichier X est corrompu, ce qui est mieux que le découvrir trop tard dans une sauvegarde).

### c. Balance (rééquilibrage de l’allocation)

La commande **balance** sert à réorganiser les données sur le(s) disque(s) d’un volume Btrfs. En pratique, un *balance* relit et réécrit tous les chunks de données/métadonnées selon les règles actuelles d’allocation ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=)). C’est principalement utile dans deux scénarios :

- **Équilibrage après changement de configuration** : Si vous **ajoutez un disque** à un volume, initialement les données existantes ne sont pas réparties sur ce nouveau disque. Un `btrfs balance start` va redistribuer les blocs sur l’ensemble des disques (par exemple répartir sur 3 disques ce qui était sur 2). Inversement, après le retrait d’un disque, un balance peut s’assurer que les données sont bien re-dupliquées correctement sur les disques restants. De même, quand on convertit un profil RAID (via `-dconvert`/`-mconvert`), c’est un balance en fait qui effectue le travail de copie.
- **Récupérer de l’espace “perdu” / réduire la fragmentation de l’espace** : Sur un seul disque, si vous faites énormément de snapshots et de suppressions, ou que le volume frôle le plein, vous pouvez vous retrouver avec beaucoup d’espace alloué mais pas réellement utilisé (des blocs libérés mais encore réservés dans des chunks d’allocation). Un balance avec des filtres permet de **libérer ces blocs épars** en consolidant les données. Par exemple, `btrfs balance start -dusage=5 /mnt` va relocaliser uniquement les chunks de données dont le taux d’occupation est ≤5% (donc majoritairement vides) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=)), afin de pouvoir les libérer complètement. Cela aide à résoudre les erreurs “No space left on device” dues à la fragmentation de l’espace libre.

Une commande typique :  
```bash
# btrfs balance start -v -musage=0 -dusage=0 /mnt/point_de_mount
```  
Celle-ci va déplacer **tous** les chunks de données et métadonnées partiellement utilisés (usage <100%) vers de nouveaux chunks bien compacts, puis libérer les anciens. C’est un peu l’équivalent d’un défrag au niveau de l’allocation de l’espace global. **Attention** : un balance total (sans filtre) peut être une opération très lourde sur un volume de grande taille (plusieurs heures, beaucoup d’I/O). Ne le lancez pas inutilement. Btrfs n’a pas besoin de balances réguliers comme on défragmenterait un disque NTFS. Utilisez-le surtout lors de modifications (ajout/retrait de disques) ou en dépannage quand l’espace est mal utilisé.

Vous pouvez exécuter le balance en arrière-plan avec `btrfs balance start --bg` (il tournera alors sans bloquer votre terminal) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=needed%20for%20fixing%20,issues)). Surveillez avec `btrfs balance status`. Notez que vous pouvez interrompre un balance en cours (`btrfs balance cancel`) et le reprendre plus tard (`btrfs balance resume`) – il reprend là où il s’était arrêté.

**En RAID5/6**, le balance a un rôle additionnel : il est *nécessaire* pour recréer la parité manquante si un disque a échoué. Mais comme dit, évitez d’utiliser RAID5/6 en production.

En résumé, **le balance n’est pas une opération à faire fréquemment de façon planifiée**, mais connaissez son existence pour : redistribuer les données après un changement de topologie ou si votre volume est presque plein alors qu’il devrait y avoir de l’espace libre (c’est souvent que l’espace est dans des chunks à moitié vides que seul un balance peut réorganiser).

### d. Défragmentation et optimisation des fichiers

Malgré le CoW, Btrfs offre des moyens de contrer la **fragmentation** des fichiers :

- **Montage avec `autodefrag` :** C’est une option de montage qui active la **défragmentation automatique en arrière-plan** pour les fichiers qui subissent de nombreuses petites écritures aléatoires ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Defragmentation)). À chaque écriture, Btrfs détecte si c’est petit (<16 KiB) et potentiellement aléatoire, et programme une défrag partielle du fichier pour recoller les morceaux. Cela est particulièrement efficace pour les bases de données (SQLite, par ex) et certains workloads (journaux). L’impact performance est généralement faible, mais sur un volume où presque chaque écriture est aléatoire (grosse base de données très active), autodefrag pourrait induire des écritures additionnelles. À tester selon les cas. Pour l’activer : montez avec l’option `autodefrag` (dans fstab ou via mount -o).
- **Défragmentation manuelle :** Vous pouvez lancer `btrfs filesystem defragment` sur un fichier ou un répertoire pour réécrire contiguïsement les données. Par exemple :  
  ```bash
  # btrfs filesystem defragment /mnt/data/mon_gros_fichier.bin
  ```  
  ou avec `-r` sur un dossier entier. Ceci ne touche qu’un sous-volume à la fois (ne traverse pas les sous-volumes enfants). Combinez avec `-c` pour compresser en même temps (voir section compression). **Mise en garde** : comme mentionné, défragmenter un fichier qui a des copies CoW (snapshots) va entraîner une duplication des données dans l’instantané et donc consommer de l’espace ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=Warning%3A%20Defragmenting%20a%20file%20which,effectively%20increasing%20the%20disk%20usage)). N’utilisez pas défrag sur des volumes avec de nombreux snapshots stables (sauf si vous comptez les supprimer ensuite). Le cas d’usage typique de la défrag manuelle est un fichier de VM ou base de données devenu très fragmenté : on peut planifier de le défragmenter périodiquement (ex: une fois par semaine de nuit) pour maintenir des performances constantes.

- **`nodatasum` et `nodatacow` sur certains fichiers** : Pour des workloads spécifiques, on l’a vu, on peut désactiver CoW sur des fichiers et ainsi éviter la fragmentation à la source. Cela s’accompagne de la perte de checksum (`nodatasum`). C’est une optimisation ponctuelle plus qu’une opération de maintenance.

- **Eviter la fragmentation de la zone libre** : Sur un volume très utilisé, supprimer d’anciens snapshots libère des blocs épars. Un balance partiel (comme vu) peut aider à consolider. Essayez d’éviter de garder des centaines de snapshots sur un même volume, surtout si l’espace est compté, car cela multiplie les blocs partiellement utilisés une fois que les données divergent.

### e. Sauvegardes et récupération

Même avec un système de fichiers avancé comme Btrfs, **les sauvegardes externes restent indispensables**. Profitez justement des snapshots et de l’envoi incrémental pour mettre en place une stratégie de sauvegarde efficace. Par exemple : prenez un snapshot quotidien de vos données et utilisez `btrfs send` vers un disque USB ou un serveur pour stocker les changements chaque jour ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=You%20can%20also%20send%20only,do)). Ainsi, même en cas de crash complet (ou d’erreur humaine), vous pourrez récupérer vos fichiers.

En cas de pépin avec le système de fichiers (corruption que Btrfs ne peut réparer, plusieurs disques en panne, etc.) :

- **btrfs check :** c’est l’outil de vérification/réparation offline (à lancer sur un volume démonté). **Attention**, `btrfs check` avec l’option `--repair` est à utiliser en *dernier recours* et seulement après avoir lu la documentation et fait une sauvegarde, car il a des *limitations connues* et peut causer des pertes de données supplémentaires s’il est mal employé ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=match%20at%20L1205%20Warning%3A%20Since,repair%60%20switch)). Si vous suspectez une corruption, tentez d’abord un `btrfs check --readonly` pour voir l’étendue des dégâts. Dans la plupart des cas, les corruptions courantes sont gérables via scrub (si redondance) ou en supprimant un fichier affecté. Ne lancez `--repair` qu’avec prudence.
- **Outils de récupération :** Btrfs fournit `btrfs rescue` (avec sous-commandes comme `super-recover`, `chunk-recover`) pour des cas avancés de récupération d’un volume ne se montant plus. Là encore, à utiliser en consultant la documentation officielle si vous êtes confronté à une situation de volume dégradé.

### f. Conseils de performance et configuration

- **Options noatime/nodiratime :** Comme sur tout système de fichiers, monter avec `noatime` (ne pas mettre à jour la date d’accès aux fichiers) peut éviter de petites écritures inutiles à chaque lecture de fichier. Par défaut, beaucoup de distributions utilisent `relatime` qui atténue déjà le problème. Mais sur un disque très sollicité, `noatime` peut être bénéfique.
- **TRIM (Discard) sur SSD :** Btrfs prend en charge la commande TRIM pour SSD. Vous pouvez soit monter avec l’option `discard=async` (depuis kernel 5.6, TRIM asynchrone efficace) pour libérer immédiatement les blocs effacés, soit exécuter périodiquement `fstrim -A` via cron/systemd. Dans un usage desktop, la **timers `fstrim.timer`** hebdomadaire par défaut convient bien et évite l’impact en temps réel d’un discard constant.
- **Mode SSD :** Btrfs détecte en principe automatiquement si le support est un SSD et adapte certains comportements (il aligne la taille des allocations différemment, etc.). L’option de montage `ssd` force ce mode, `nossd` le désactive. Il existe aussi `ssd_spread` qui répartit davantage les métadonnées pour éviter les amplifications d’écriture sur SSD, mais il est généralement déconseillé car il peut causer plus de fragmentation. En général, laissez l’auto-détection (ou spécifiez `ssd` si votre SSD n’est pas bien détecté derrière du RAID matériel ou autre).
- **Mettre à jour Btrfs-progs et le kernel :** Btrfs est en constante amélioration. Utilisez les versions récentes du noyau et des outils `btrfs-progs` pour bénéficier des optimisations et corrections de bugs. Par exemple, la gestion améliorée de RAID1c3/RAID1c4, l’introduction de `discard=async`, les optimisations de Zstd, etc. sont arrivées avec le temps.
- **Partition d’alignment** : Btrfs fonctionne généralement sans tuning particulier sur la plupart des supports. Si vous utilisez un RAID matériel ou un LVM sous-jacent, assurez-vous que l’alignement est correct pour éviter des lectures/écritures pénalisées (mais c’est valable pour tout FS, pas propre à Btrfs).

En suivant ces bonnes pratiques, vous devriez tirer le meilleur parti de Btrfs : un système de fichiers **fiable, flexible et puissant**. Profitez de ses instantanés pour sécuriser vos manipulations, de sa compression pour économiser de l’espace, et de sa gestion multi-disques pour adapter le stockage à vos besoins. N’oubliez pas de surveiller ponctuellement l’état du système (`scrub`, `device stats`) et de maintenir des sauvegardes externes. Avec un entretien approprié, Btrfs peut considérablement faciliter la gestion de vos données sous Linux au quotidien, en alliant performance et sécurité des informations.

**Sources :** Btrfs Wiki & documentation officielle ([Introduction — BTRFS  documentation](https://btrfs.readthedocs.io/en/latest/Introduction.html#:~:text=administration,benefits%20are)) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=The%20Btrfs%20Wiki%20Glossary%20says,and%20repair%20any%20corrupt%20data)), ArchLinux Wiki – *Btrfs* ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=To%20disable%20copy,See%20btrfs%285%29%20for%20details)) ([Btrfs - ArchWiki](https://wiki.archlinux.org/title/Btrfs#:~:text=,Snapshots%20for%20details)), Wiki Ubuntu-fr – *Le système de fichiers BTRFS* ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,%C3%A9criture%20%28cf.%20plus%20bas)) ([btrfs [Wiki ubuntu-fr]](http://doc.ubuntu-fr.org/btrfs#:~:text=,les%20disques%20seront%20utilis%C3%A9s%20simultan%C3%A9ment)), etc.